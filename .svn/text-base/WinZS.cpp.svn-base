/* нхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнх
 └█╝║└╧   : 1995│т 3┐∙ 27└╧
 └█╝║└┌   : └х ╝о▒╘
 Compile  : bcc -ms
 ╚н└╧ ╝│╕э: └╠ ╚н└╧└║ ╜║┼й╕│╞о │╗┐ы└╗ ╣о╣¤└√└╕╖╬ ╟╪╝о╟╧░э └╠░═└╗ ╜╟╟р▒т░б
            ╛╡╝Ў └╓┤┬ │╗┐ы└╟ └╠┴° ╚н└╧╖╬ ╗¤╝║╟╤┤┘.
            * ╕Ё╡ч ╟╘╝Ў╕э└║ 1╣┘└╠╞о╖╬ ║п╚п╡╚┤┘. ▒╫╖п╣╟╖╬ ├╓┤ы ╕э╖╔╛ю└╟ ░╣
              ╝Ў┤┬ │╗║╬, ┐▄║╬ ╕э╖╔╛ю ╟╒├─╝н 255░│└╠┤┘.
            * ╕Ё╡ч ║п╝Ў┤┬ ╜╟┴ж░к░· 0x8000└╗ OR╟╪╝н ╗¤╝║╜├┼▓┤┘.
			* ╕Ё╡ч ╝Ў─б░к└║ ╜╟┴ж░к└╗ ╡√╕е┤┘. ( 0 ~ 32767 )
            * ╕Ё╡ч GOTO ╕э╖╔└╟ ┴б╟┴ ┴╓╝╥┤┬ 2╣┘└╠╞о└╠┤┘.
            * switch╣о┐б╝н case╣о└║ ├╓┤ы 50░│└╠┤┘.


date of Modification : 1997│т 10┐∙ 30└╧
who modified : Kim Hongseok
contents of modification : porting of windows
нхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнх */
#include "StdAfx.h"
//#include <Windows.h>
//#include <dos.h>
//#include <stdio.h>
//#include <stdlib.h>
#include <conio.h>
#include <string.h>
#include <ctype.h>
#include <io.h>
#include <stdarg.h>

#define __WINZS_H__
#include "WinZs.h"

#include "Scrp_int.h"


#ifndef __TYPEDEF__
    typedef unsigned char  BYTE;
    typedef unsigned short WORD;
    typedef unsigned long  DWORD;
#endif


#define MAX_SCR_ARRAY     10000


// ░в ╕э╖╔╛ю┐б ╟╪┤ч╟╧┤┬ ╣о└┌┐н└╟ ░к└╗ ┴д└╟╟╤┤┘.
// ┤┘└╜└╟ ┴д└╟╣о└║ ──╞─└╧╡╚ └╠┴°╚н└╧┐б ╜╟┴ж╖╬ ╛▓┐й┴Ў┤┬ ░к└╠┤┘.
/*
enum {
    goto_     =  0xe0,
    if_       =  0xe1,
    call_     =  0xe2,
    add_      =  0xe3,
    sub_      =  0xe4,
    mul_      =  0xe5,
    div_      =  0xe6,
    rest_     =  0xe7,
    equal_    =  0xe8,
    end_      =  0xe9,
    ifequal_  =  0xea,
    or_       =  0xeb,
    and_      =  0xec,
    variable_ =  0xed,
    value_    =  0xee,
    add2_     =  0xef,
    sub2_     =  0xf0,
    mul2_     =  0xf1,
    div2_     =  0xf2,
    rest2_    =  0xf3,
    or2_      =  0xf4,
    and2_     =  0xf5,
};
*/
// ┤┘└╜└╟ ┴д└╟╣о└║ ──╞─└╧╟╥╢з╕╕ ┐ф▒╕╡╟┤┬ ░к└╠┤┘.
enum {
    else_     =  0xd0,
    case_     =  0xd1,
    endswitch_=  0xd2,
    default_  =  0xd3,
    switch_   =  0xd4,
    break_    =  0xd5,
    include_  =  0xd6,
};


#define LABEL_LENGTH 20        // ╢є║з└╟ ├╓┤ы ▒ц└╠╕ж │к┼╕│┐

enum {
    END = 0,
    DELIMITER,
    VARIABLE,
    NUMERIC,
    FUNCTION,
    STRING,
    LABEL,
    COMMAND,
    USERFUNC,
};


typedef struct {
    char s[ 50 + 1 ];
    int n;
} COMMSET;


typedef struct {        // if_else ╣о└╟ │╗┐ы└╗ └·└х╟╧▒т └з╟╤ ▒╕┴╢├╝
    int off;            // if│к else╣о└╠ └з─б╟╤ ░ў└╟ ┐╔╝┬
    BYTE d;             // ▒э└╠╕ж │к┼╕│┐
    BYTE t;             // 0 = if, 1 = else
} IF_ELSE;


typedef struct {        // ╗ч┐ы└┌░б ┴д└╟╟╤ ╟╘╝Ў╕э└╗ └·└х╟╥ ▒╕┴╢├╝
    char s[ 50 + 1 ];       // ╟╘╝Ў╕э└╗ └·└х╟╥ ║п╝Ў
    char format[ 31 ];  // ╟╘╝Ў┐б ╟╪┤ч╟╧┤┬ └╬╝Ў└╟ format└╗ └·└х╟╥ ║п╝Ў
    int n;             // ╟╘╝Ў╕э└╠ └╓┤┬░ў└╟ └з─б
} USER_FUNC;


typedef struct {        // switch ╣о└╟ │╗┐ы└╗ └·└х╟╥ ▒╕┴╢├╝
    int total;          // ╟┴╖╬▒╫╖е ├│└╜┐б case└╟ ░╣╝Ў╕ж ┴╢╗ч╟╤ │╗┐ы
    int count;
    int def;
    int numoff[ 50 ];
} SWITCHCASE;


// ░в░в┐б ╟╪┤ч╟╧┤┬ ╕э╖╔╛ю┐═ ▒╫ ╕э╖╔╛ю┐б ╟╪┤ч╟╧┤┬ ╝¤└┌╕ж ░б┴Ў┤┬ ▒╕┴╢├╝
static COMMSET comm[ 255 ] = {
    { "goto",           goto_ },
    { "if",             if_ },
    { "call",           call_ },
    { "end",            end_ },
    { "else",           else_ },
    { "switch",         switch_ },
    { "case",           case_ },
    { "endswitch",      endswitch_ },
    { "default",        default_ },
    { "break",          break_ },
    { "include",        include_ },
};


static COMMSET variable[ MAX_SCR_ARRAY ];             // ╗ч┐ы└┌░б ┴д└╟╟╤ ║п╝Ў└╟ │╗┐ы└╗ └·└х
static COMMSET label1[ MAX_SCR_ARRAY ];               // ┐°╖б ╢є║з└╟ │╗┐ы└╗ └·└х╟╧┤┬ ║п╝Ў
static COMMSET label2[ MAX_SCR_ARRAY ];               // goto╣о ┤┘└╜┐б ╛▓└╬ ╢є║з└╗ └·└х
static IF_ELSE ifelse[ MAX_SCR_ARRAY ];               // if, else╣о└╟ │╗┐ы└╗ └·└х
static COMMSET userfunc1[ MAX_SCR_ARRAY ];            // ┐°╖б ╟╘╝Ў╕э└╟ │╗┐ы└╗ └·└х
static COMMSET userfunc2[ MAX_SCR_ARRAY ];            // call╣о ┤┘└╜┐б ╛▓└╬ ╟╘╝Ў╕ж └·└х
static USER_FUNC function[ MAX_SCR_ARRAY ];           // └п└·░б ┴д└╟╟╤ ╟╘╝Ў╕ж └·└х
static SWITCHCASE swit[ 50 ];               // ╟╧│к└╟ switch╣о┐б╝н ░в░в└╟
                                     // case╣о└╗└·└х

static char TOKEN[ MAX_SCR_ARRAY ];                    // ║╥╕о╟╪│╜ ┼ф┼л└╗ └·└х╟╥ ╣Ў╞█
static char TOKENTYPE;                      // ╛Є╛ю┴° ┼ф┼л└╟ ┼╕└╘
static int  TOK;                            // ┼ф┼л└╗ ║п╚п╟╤ ╚─└╟ ░к└╗ └·└х

static int ifsp;                            // if, else└╟ ╜║┼├░к
static int switsp;                          // switch└╟ ║п└з░к
static int label1_n, label2_n;              // ┐°╖б└╟ ╢є║з░к░· ╛▓┐й┴° ╢є║з░к└╗ └·└х
static int user1_n, user2_n;                // ┐°╖б└╟ ╟╘╝Ў░к░· ╛▓┐й┴° ╟╘╝Ў░к└╗ └·└х
static int funclabelsp;						// GetLabel () ╟╘╝Ў┐б╝н ╗ч┐ы

static int LINE = 0;                        // ╝╥╜║╚н└╧└╟ ╢є└╬░к└╗ ─л┐ю╞о

BYTE *wzsprog,                          // ╝╥╜║ ╟┴╖╬▒╫╖е└╗ └╨╛ю╡щ└╧ ╣Ў╞█
	 *oldwzsprog;                       // ├│└╜┐б┤┬ wzsprog┐═ ░░└║ ░к└╗ ░б┴Ў╕ч
									 // ╟┴╖╬▒╫╖е ┴╛╖с╜├ free╟╘╝Ў┐б╝н ╗ч┐ы
static BYTE *outprog,                       // ├т╖┬ ╣Ў╞█╕ж ░б╕о┼┤
			*oldoutprog;                    // ├│└╜┐б┤┬ oldoutprog┐═ ░░└║ ░к└╗ ░б┴Ў╕ч
                                     // ╟┴╖╬▒╫╖е ┴╛╖с╜├ free╟╘╝Ў┐б╝н ╗ч┐ы
static int SOURCEFILESIZE;                  // ╝╥╜║╚н└╧└╟ ┼й▒т╕ж │к┼╕│┐
static char TARGETFILENAME[ FILENAME_MAX];             // ├т╖┬╟╥ ╚н└╧└╟ └╠╕з└╗ │к┼╕│┐
static FILE *outfile;                       // ├т╖┬╟╥ ╚н└╧└╗ ░б╕о┼░┤┬ ╚н└╧ ╞ў└╬┼═
static int INCLUDEFILESIZE;                 // └╬┼м╖ч╡х╡╔ ╚н└╧└╟ ┼й▒т╕ж ░б╕о┼┤

static int ErrorCount;


static char Wz_scriptfilename[FILENAME_MAX];


// Scrp_int.cpp
extern int func_off[100];

//////////////////////////////////////////////////////////////////////////
// ╜╟┴·└√└╬ ╟╘╝Ў╡щ└╟ ┴д└╟
//////////////////////////////////////////////////////////////////////////




//------------------------------------------------------------------------

enum {
    ZS_FALSE,
    ZS_TRUE,
};

#define ZSAlloc(x)      ZS_Alloc( (x), __FILE__, __LINE__ )

void ZSError( char *s, ... )
{
    va_list arg;
	char temp[ FILENAME_MAX];

    va_start( arg, s );
    vsprintf( temp, s, arg );
    va_end( arg );

	MessageBox( 0, s, "ZSerror", MB_OK );

    exit( 1 );
}








char *ZS_Alloc( int size, const char *file, int line )
{
    char *memorytemp;
	memorytemp = (char *)GlobalAlloc( GMEM_FIXED, size );
    //memorytemp = (char *)malloc( size );

    if( !memorytemp )
        ZSError( "%s(%d) : \n %d alloc Err\n", file, line, size );

    return( memorytemp );
}


void ZSfree( void *t )
{
	GlobalFree( t );
//	free( t );
}



FILE *ZS_Fopen( const char *file, const char *mode )
{
    FILE *tempfile;

    tempfile = fopen( file, mode );
    if( !tempfile )
        ZSError( "%s FILE PROCESS ERROR.\n", file );

    return( tempfile );
}

//------------------------------------------------------------------------





/* нхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнх
 ╟╘╝Ў╕э : Incode
 └╬  └┌ : s = ╛╧╚г╚н╟╥ ╣о└┌┐н
 ╕о┼╧░к : ╛°└╜
 ╝│  ╕э : s╣о└┌┐н└╗ ╣▐╛╞╝н │╗║╬┐б ┴д└╟╡╚ ╝Ў─б┐═ ┐м╗ъ└╗ ╝Ў╟р╟╪╝н ╛╧╚г╚н╟╘
нхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнх */
void WinZsIncode( char *s )
{
//    static BYTE t[ 20 ] = {
//        101, 255, 168, 210, 184, 47, 176,  54,  58, 63,
//         78,   1,  34,  69, 200,  88,  77, 111, 48, 121
//    };
    BYTE t = 0xff;
    int i = 0;

    while( *s ) {
        (*s++) ^= 0xff;
        if( ++i > 19 ) i = 0;
    }
}


/* нхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнх
 ╟╘╝Ў╕э : SearchFunction
 └╬  └┌ : s = ├г░э└┌ ╟╧┤┬ ╟╘╝Ў└╟ ╣о└┌┐н
 ╕о┼╧░к : ├г┴Ў╕°╟╧╕щ -1, ├г└╕╕щ ╣°╚г╕ж ╕о┼╧
 ╝│  ╕э : s╣о└┌┐н┐б ╟╪┤ч╟╧┤┬ └п└·░б ┴д└╟╟╤ ╟╘╝Ў╕э└╗ function╣ш┐н┐б╝н ├г┤┬┤┘.
нхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнх */
int SearchFunction( char *s )
{
    int i;

	for( i = 0; function[i].s[0] != 0; i++ )
        if( !strcmp( function[i].s, s ) ) return( i );

    return( -1 );
}


/* нхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнх
 ╟╘╝Ў╕э : SearchCommand
 └╬  └┌ : s = ├г░э└┌╟╧┤┬ ╕э╖╔╛ю└╟ ╣о└┌┐н
 ╕о┼╧░к : ├г┴Ў╕°╟╧╕щ -1, ├г└╕╕щ ╣°╚г╕ж ╕о┼╧
 ╝│  ╕э : s╣о└┌┐н┐б ╟╪┤ч╟╧┤┬ ╕э╖╔╛ю╕ж ├г└╜
нхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнх */
int SearchCommand( char *s )
{
	int i;

    for( i = 0; comm[i].s[0] != 0; i++ )
        if( !strcmp( comm[i].s, s ) ) return( i );

    return( -1 );
}


/* нхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнх
 ╟╘╝Ў╕э : SearchVariable
 └╬  └┌ : s = ├г░э└┌ ╟╧┤┬ ║п╝Ў└╟ ╣о└┌┐н
 ╕о┼╧░к : ├г┴Ў╕°╟╧╕щ -1, ├г└╕╕щ ╣°╚г╕ж ╕о┼╧
 ╝│  ╕э : s╣о└┌┐н┐б ╟╪┤ч╟╧┤┬ ║п╝Ў╕э└╗ ├г└╜
нхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнх */
int SearchVariable( char *s )
{
    int i;

    for( i = 0; variable[i].s[0] != 0; i++ )
		if( !strcmp( variable[i].s, s ) ) return( i );

    return( -1 );
}


/* нхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнх
 ╟╘╝Ў╕э : SearchLabel
 └╬  └┌ : s = ├г░э└┌ ╟╧┤┬ ╢є║з└╟ ╣о└┌┐н
 ╕о┼╧░к : ├г┴Ў╕°╟╧╕щ -1, ├г└╕╕щ ╣°╚г╕ж ╕о┼╧
 ╝│  ╕э : s╣о└┌┐н┐б ╟╪┤ч╟╧┤┬ ╢є║з└╗ ├г└╜
нхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнх */
int SearchLabel( char *s )
{
    int i;

    for( i = 0; label1[i].s[0] != 0; i++ )
        if( !strcmp( label1[i].s, s ) ) 
			return( i );

    return( -1 );
}



/* нхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнх
 ╟╘╝Ў╕э : SearchUserFunc
 └╬  └┌ : s = ├г░э└┌ ╟╧┤┬ └п└·░б ┴д└╟╟╤ ╟╘╝Ў└╟ ╣о└┌┐н
 ╕о┼╧░к : ├г┴Ў╕°╟╧╕щ -1, ├г└╕╕щ ╣°╚г╕ж ╕о┼╧
 ╝│  ╕э : ╝╥╜║┐б╝н ┴д└╟╟╤ s╣о└┌┐н┐б ╟╪┤ч╟╧┤┬ ╟╘╝Ў╕э└╗ ├г└╜
          ╟╘╝Ў╕э└║ ╣▌╡х╜├ '_'╖╬ ╜├└█╡╟╛ю╛▀ ╟╘
нхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнх */
int SearchUserFunc( char *s )
{
    int i;

    for( i = 0; userfunc1[i].s[0] != 0; i++ )
        if( !strcmp( userfunc1[i].s, s ) ) return( i );

    return( -1 );
}




/* нхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнх
 ╟╘╝Ў╕э : Serror
 └╬  └┌ : x = ├т╖┬╟╧░э└┌ ╟╧┤┬ ┐б╖п ╕▐╜├┴Ў└╟ ╣°╚г
 ╕о┼╧░к : ╛°└╜
 ╝│  ╕э : x┐б ╟╪┤ч╟╧┤┬ ┐б╖п ╕▐╜├┴Ў╕ж ├т╖┬╟╧░э ╟┴╖╬▒╫╖е└╗ ┴╛╖с╟╤┤┘.
нхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнх */
void Serror( int x )
{
    char *s[] = {
        "Compile completed.",             // 0
        "Systax error",                   // 1
        "Unbalanced ()",                  // 2
        "Unbalanced {}",                  // 3
        "Too few patameter",              // 4
        "Mismatch patameter",             // 5
        "Invalid patameter",              // 6
        "Invalid Label",                  // 7
		"Too long label name",            // 8
        "Label name is not found",        // 9
        "Lvalue required",                // 10
        "Stack overflow",                 // 11
        "Mismatch if - else",             // 12
        "Mismatch function - end",        // 13
        "Name already exist",             // 14
        "Function name not found",        // 15
        "Symbol not found",               // 16
        "Data file (zs.dat) open error",  // 17
        "Numeric is too big",             // 18
        "file create error",              // 19
        "Not found variable",             // 20
        "Mismatch Switch - endswitch",    // 21
        "Variable not found",             // 22
        "File not found",                 // 23
    };

//    ZSfree( oldwzsprog );
//    ZSfree( oldoutprog );

	ErrorCount++;

	remove( TARGETFILENAME );


	char nn[ FILENAME_MAX];
	strcpy( nn, Wz_scriptfilename );
	for( int i = strlen( nn ) - 1  ; i > 0  ; i -- )	   if( *(nn + i ) == '\\' ) break;
	
//	sprintf( temp, "%s: %d line: '%s'\n\n ' %s '╕ж ┐н▒ю┐ф?",s[x], LINE, TOKEN,  strupr( nn+i+1) );
//	if( YesOrNo( temp, "Script Compile Error") == IDYES )	NotePad( Wz_scriptfilename );



#ifdef MAKE_EXE_FILE	
    if( x == 0 ) printf( "\n%s\n", s[0] );
    else {
        printf( "\n\aError:\n%5d LINE: '%s' %s\n", LINE, TOKEN, s[x] );
    }
	printf( "Anyway, Process?( y/N ) ");
	t = _getch();
	if( t == 'y' || t== 'Y' ) return;
	else exit(1);
#endif
 }



/* нхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнх
 ╟╘╝Ў╕э : Isdeli
 └╬  └┌ : i = ░╦╗ч╟╥ ╣о└┌
 ╕о┼╧░к : ▒╕║╨╣о└┌└╠╕щ 1, ╛╞┤╧╕щ 0
 ╝│  ╕э : i╣о└┌░б ▒╕║╨╣о└┌└╬┴Ў╕ж ░╦╗ч╟╤┤┘.
нхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнх */
int Isdeli( char i )
{
    if( strchr( " ';,+-*/%#=<>(){}[]:!@\t&|", i ) )
        return( 1 );

    return( 0 );
}



/* нхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнх
 ╟╘╝Ў╕э : Isspace
 └╬  └┌ : i = ░╦╗ч╟╥ ╣о└┌
 ╕о┼╧░к : ░°╣щ, ┼╟, ╕о┼╧, ╢є└╬ ╟╟╡х╣о└┌└╠╕щ 1, ╛╞┤╧╕щ 0
 ╝│  ╕э : i╣о└┌░б ░°╣щ, ┼╟, ╕о┼╧, ╢є└╬ ╟╟╡х╣о└┌└╬┴Ў╕ж ░╦╗ч╟╤┤┘.
нхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнх */
int Isspace( char i )
{
    switch( i ) {
        case 0x0a:        // ╢є└╬ ╟╟╡х ╣о└┌└╠╕щ LINE║п╝Ў╕ж ╟╧│к ┴ї░б╟╤┤┘.
            LINE++;
        case 0x0d:
		case '\t':
        case ' ':
            return( 1 );
        default:
            return( 0 );
    }
}



/* нхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнх
 ╟╘╝Ў╕э : PutToken
 └╬  └┌ : ╛°└╜
 ╕о┼╧░к : ╛°└╜
 ╝│  ╕э : TOKEN╣ш┐н└╟ │╗┐ы└╗ wzsprog┐б ┤┘╜├╛┤┤┘.
нхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнх */
void PutToken( void )
{
    int i;

	i = strlen( TOKEN );

    while( i ) {
        *--wzsprog = TOKEN[ i - 1 ];
        i--;
    }
    if( TOKENTYPE == LABEL ) {
        *--wzsprog = ':';
    }
}



/* нхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнх
 ╟╘╝Ў╕э : GetToken
 └╬  └┌ : ╛°└╜
 ╕о┼╧░к : ┼ф┼л ┼╕└╘└╗ ╕о┼╧╟╤┤┘.
 ╝│  ╕э : wzsprog╣Ў╞█╕ж ║╨╝о╟╪╝н ┼ф┼л└╗ ╛Є┤┬┤┘.
нхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнх */
int GetToken( void )
{
    register char *temp;

    // ┼ф┼л ╣Ў╞█╕ж ├╩▒т╚н ╟╤┤┘.
    temp = TOKEN;
    TOKENTYPE = 0;
	TOK = 0;

start:
    // ╚н└╧└╟ │б┐б ┤┘┤┘╢·└╗╢з
    if( *wzsprog == 0 ) return( TOKENTYPE = END );

    // ░°╣щ, ┼╟╣о└┌, ╕о┼╧, ╢є└╬╟╟╡х ╣о└┌╕ж ╛°╛╪┤┘.
    while( Isspace( *wzsprog ) ) ++wzsprog;
    if( *wzsprog == 0 ) goto start;        // ╚н└╧└╟ │б└╠╕щ

    // ╢є║з╕э└╠╕щ TOKEN║п╝Ў┐б └╠╕з└╗ └·└х╟╧░э ╕о┼╧
    if( *wzsprog == ':' ) {
        if( Isdeli( *++wzsprog ) ) { Serror( 7 ); return -1; } // ╢є║з╕э└║ ┐╡╣о└┌┐═ ╝¤└┌╖╬ ▒╕╝║ 
        while( !Isdeli(*wzsprog) && *wzsprog != '\r' && *wzsprog != 0 )
			*temp++ = *wzsprog++;
        *temp = 0;
        return( TOKENTYPE = LABEL );
    }

    // ┴╓╝о└╠╕щ ╢є└╬└╟ │б▒ю┴Ў╕ж ╜║┼╡╟╧░э ┤┘╜├ ├│└╜└╕╖╬ ╡╣╛╞░г┤┘.
    if( *wzsprog == ';' ) {
        ++wzsprog;
        while( *wzsprog != '\n' && *wzsprog++ != 0 );
        goto start;
    }

    // ╗ч┐ы└┌ ┴д└╟ ╟╘╝Ў└╠╕щ
    if( *wzsprog == '@' ) {
        ++wzsprog;
        while( !Isdeli(*wzsprog) && *wzsprog != '\r' && *wzsprog != 0 )
            *temp++ = *wzsprog++;
        *temp = 0;
        TOK = SearchUserFunc( TOKEN );
        return( TOKENTYPE = USERFUNC );
	}

    // ▒╕║╨╣о└┌└╠╕щ
    if( Isdeli( *wzsprog ) ) {
        *temp++ = *wzsprog++;
        *temp = 0;
        return( TOKENTYPE = DELIMITER );
    }

    // ╣о└┌┐н└╠╕щ
    if( *wzsprog == '"' ) {
        ++wzsprog;
        while( *wzsprog != '"' && *wzsprog != '\r' && *wzsprog != 0 )
            *temp++ = *wzsprog++;
        // ╕╢┴Ў╕╖ ╣о└┌░б ╢є└╬╟╟╡х│к ╚н└╧└╟ │б└╠╕щ ┐б╖п
        if( *wzsprog == '\r' || *wzsprog == 0 ) { Serror( 1 ); return -1; }
        *temp = 0;
        wzsprog++;        // '"'╣о└┌╕ж ╜║┼╡
        return( TOKENTYPE = STRING );
    }

    // ╝¤└┌└╠╕щ
    if( isdigit(*wzsprog) ) {
        while( isdigit(*wzsprog) && !Isdeli(*wzsprog) &&
               *wzsprog != '\r' && *wzsprog != 0 )
            *temp++ = *wzsprog++;
        *temp = 0;
        return( TOKENTYPE = NUMERIC );
    }

    // ╕э╖╔╛ю│к ╢є║з, ║п╝Ў╕ж ├╝┼й
    if( isalpha(*wzsprog) ) {
        while( !Isdeli(*wzsprog) && *wzsprog != '\r' && *wzsprog != 0 )
            *temp++ = *wzsprog++;
        *temp = 0;

        // ╕╕╛р ╛Є╛ю┴° ╣о└┌┐н└╠ ╕э╖╔╛ю╢є╕щ
        TOK = SearchCommand( TOKEN );
        if( TOK != -1 ) return( TOKENTYPE = COMMAND );

		// ╕╕╛р ╛Є╛ю┴° ╣о└┌┐н└╠ ║п╝Ў╢є╕щ
        TOK = SearchVariable( TOKEN );
        if( TOK != -1 ) return( TOKENTYPE = VARIABLE );

        // ╕╕╛р ╛Є╛ю┴° ╣о└┌┐н└╠ ╢є║з╕э└╠╢є╕щ
        TOK = SearchLabel( TOKEN );
        if( TOK != -1 ) return( TOKENTYPE = LABEL );

        // ╕╕╛р ╛Є╛ю┴° ╣о└┌┐н└╠ ╗ч┐ы└┌ ┴д└╟ ╟╘╝Ў╕э└╠╢є╕щ
        TOK = SearchFunction( TOKEN );
        if( TOK != -1 ) return( TOKENTYPE = FUNCTION );

        // ▒╫┐▄┤┬ ╣о└┌┐н╖╬ ░г┴╓
        return( TOKENTYPE = STRING );
    }

	{ Serror( 1 ); return -1; }

     return( TOKENTYPE );
}



/* нхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнх
 ╟╘╝Ў╕э : WriteInt
 └╬  └┌ : x = outprog┐б ├т╖┬╟╧░э└┌ ╟╧┤┬ ░к
 ╕о┼╧░к : ╛°└╜
 ╝│  ╕э : x┐б ╟╪┤ч╟╧┤┬ ░к└╗ outprog╣Ў╞█┐б ▒т╖╧╟╤┤┘.
нхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнх */
void WriteInt( int x )
{
    *((int *)outprog) = x;
    outprog += sizeof( int );
}



/* нхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнх
 ╟╘╝Ў╕э : WriteBYTE
 └╬  └┌ : x = outprog╣Ў╞█┐б ├т╖┬╟╧░э└┌ ╟╧┤┬ ░к
 ╕о┼╧░к : ╛°└╜
 ╝│  ╕э : x┐б ╟╪┤ч╟╧┤┬ ░к└╗ outprog╣Ў╞█┐б ▒т╖╧╟╤┤┘.
нхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнх */
void WriteBYTE( char x )
{
    *outprog++ = x;
}



/* нхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнх
 ╟╘╝Ў╕э : First
 └╬  └┌ : ╛°└╜
 ╕о┼╧░к : ╛°└╜
 ╝│  ╕э : '}' ▒т╚г╕ж ╣▀░▀╟╧╕щ ifelse ╜║┼├└╗ ╞╦╟╧░э ╡е└╠┼╕╕ж ├│╕о╟╤┤┘.
нхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнх */
int First( void )
{
    --ifsp;

    if( ifsp < 0 ){ Serror( 3 );  return -1; }       // ifelse ╜║┼├└╠ ┐└╣Ў╟├╖╬┐ь ╡╞└╗░ц┐ь
    if( ifelse[ ifsp ].d != ifsp ) { Serror( 3 ); return -1; }  // ╜║┼├└╟ ▒э└╠░б ╕┬┴Ў╛╩└╗ ░ц┐ь

    *((int *)(oldoutprog + ifelse[ifsp].off )) =
        outprog - oldoutprog;

	return 1;
}



/* нхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнх
 ╟╘╝Ў╕э : Inc
 └╬  └┌ : ╛°└╜
 ╕о┼╧░к : ╛°└╜
 ╝│  ╕э : ╗ч─в┐м╗ъ, %, |, &, ~ ┐м╗ъ└╗ ╝Ў╟р╟╤┤┘.
нхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнх */
int Inc( void )
{
    int jj[ 3 ][ 2 ];               // ├╣╣°┬░ ├╖└┌┤┬ ║п╝Ў└╬┴Ў ╝¤└┌└╬┴Ў╕ж │к┼╕│┐
    int i;                          // ║п╝Ў└╠╕щ 0, ╝¤└┌└╠╕щ 1
    BYTE j;

    jj[0][0] = 0;                   // ├╣╣°┬░ └╬└┌╕ж ╛Є└╜, ├╣╣°┬░ └╬└┌┤┬ ╣л┴╢░╟ ║п╝Ў
    jj[0][1] = variable[TOK].n;

    if( GetToken() == -1 ) return -1;

    if( strchr( "+-/*%|&", *TOKEN ) )      // ┴ї░и┐м╗ъ└┌╡ю└╧ ░ц┐ь
    {
        j = *TOKEN;

        if( GetToken() == -1 ) return -1;
        if( *TOKEN != '=' ){ Serror( 1 );  return -1; }

        switch( j )
        {
            case '+': j = add2_;  break;
            case '-': j = sub2_;  break;
            case '*': j = mul2_;  break;
            case '/': j = div2_;  break;
            case '%': j = rest2_; break;
            case '|': j = or2_;   break;
            case '&': j = and2_;  break;
        }
        WriteBYTE( j );

        WriteBYTE( (char)variable_ );
        WriteInt( jj[0][1] );

        if( GetToken() == -1 ) return -1;

        switch( TOKENTYPE )
        {
            case VARIABLE:
                WriteBYTE( (char)variable_ );
                WriteInt( variable[TOK].n );
                break;

            case NUMERIC:
                WriteBYTE( (char)value_ );
                WriteInt( atoi( TOKEN ) );
                break;

            default:
                {Serror( 1 );  return -1; }
        }
    }
    else
    {
        if( *TOKEN != '=' ) { Serror( 1 );  return -1; }

        if( GetToken() == -1 ) return -1;

        switch( TOKENTYPE )             // ╡╬╣°┬░ └╬└┌░б ║п╝Ў└╬┴Ў ╝¤└┌└╬┴Ў╕ж ░╦╗ч
        {
            case VARIABLE:              // ║п╝Ў└╧ ░ц┐ь ├│╕о
                jj[1][0] = 0;
                jj[1][1] = variable[TOK].n;
                break;

            case NUMERIC:               // ╝¤└┌└╧ ░ц┐ь ├│╕о
                jj[1][0] = 1;
                jj[1][1] = atoi( TOKEN );
                break;

            default:                    // ▒╫┐▄└╟ TYPE└╠╕щ ┐б╖п
                { Serror( 1 ); return -1; }
        }

        if( GetToken() == -1 ) return -1;
        if( !strchr( "+-/*%|&", *TOKEN ) )          // ╕╕╛р ┤ы└╘╣о└╠╢є╕щ
        {
            PutToken ();
            WriteBYTE( (char)equal_ );

            for( i = 0; i < 2; i++ )
            {
                if( jj[i][0] == 0 )                  // ║п╝Ў╢є╕щ
                    WriteBYTE( (char)variable_ );
                else                                 // ╝¤└┌╢є╕щ
                    WriteBYTE( (char)value_ );

                WriteInt( jj[i][1] );
            }
        }
        else                                         // ┤ы└╘╣о└╠ ╛╞┤╧╢є╕щ
        {
            switch( *TOKEN )
            {
                case '+': j = add_;  break;
                case '-': j = sub_;  break;
                case '*': j = mul_;  break;
                case '/': j = div_;  break;
                case '%': j = rest_; break;
                case '|': j = or_;   break;
                case '&': j = and_;  break;
                default : { Serror( 1 ); return -1; }
            }
            WriteBYTE( j );

            if( GetToken() == -1 ) return -1;               // ╝╝╣°┬░ └╬└┌╕ж ╛Є└╜

            switch( TOKENTYPE )
            {
                case VARIABLE:
                    jj[2][0] = 0;
                    jj[2][1] = variable[TOK].n;
                    break;

                case NUMERIC:
                    jj[2][0] = 1;
                    jj[2][1] = atoi( TOKEN );
                    break;

                default: { Serror( 1 ); return -1; }
            }

            for( i = 0; i < 3; i++ )
            {
                if( jj[i][0] == 0 )        // ║п╝Ў└╠╕щ
                    WriteBYTE( (char)variable_ );
                else                       // ╝¤└┌└╠╕щ
                    WriteBYTE( (char)value_ );

                WriteInt( jj[i][1] );
            }
        }
    } // end if

	return 1;
}




/* нхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнх
 ╟╘╝Ў╕э : GetLabel
 └╬  └┌ : ╛°└╜
 ╕о┼╧░к : ╛°└╜
 ╝│  ╕э : ╢є║з╕э└╠ └╓┤┬░ў└╟ └з─б╕ж ┴╢╗ч╟╧┐й label1║п╝Ў┐б ╝┬╞├╟╤┤┘.
нхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнх */
void GetLabel( void )
{
//    static int i;

    label1[funclabelsp++].n = (int)(outprog - oldoutprog);
}



/* нхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнх
 ╟╘╝Ў╕э : GetCommand
 └╬  └┌ : ╛°└╜
 ╕о┼╧░к : ╛°└╜
 ╝│  ╕э : ▒т║╗└√└╬ ╕э╖╔└╗ ├│╕о╟╤┤┘.
нхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнх */
int GetCommand( void )
{
    int i, j;

    switch( comm[TOK].n )
    {
        // if╣о└╗ ├│╕о╟╤┤┘.
        case if_:
            WriteBYTE( (char)if_ );

            if( GetToken() == -1 ) return -1;
            if( *TOKEN != '(' ) { Serror( 1 ); return -1; }

            if( GetToken() == -1 ) return -1;
            // ╕╕╛р ╛Є└║ ┼ф┼л└╠ ║п╝Ў░б ╛╞┤╧╢є╕щ
            if( TOKENTYPE != VARIABLE ) { Serror( 10 ); return -1; }

            WriteBYTE( (char)variable_ );                             // ║п╝Ў└╟ ░к└╗ └·└х
            WriteInt( variable[TOK].n );

            if( GetToken() == -1 ) return -1;
            if( !strchr( "<>!=", *TOKEN ) ) { Serror( 1 ); return -1; } 

            // ║ё▒│ ▒т╚г╕ж ├г╛╞╝н └√┤ч╟╤ ├│╕о╕ж ╟╤┤┘.
            // < - 0, <= - 1, > - 2, >= - 3, != - 4, == - 5
            switch( *TOKEN )
            {
                case '<':
                    if( GetToken() == -1 ) return -1;
                    if( *TOKEN != '=' )          // '<='┐м╗ъ└┌░б ╛╞┤╧╢є╕щ
                    {
                        PutToken();
                        WriteBYTE( 0 );
                    }
                    else
                    {
                        WriteBYTE( 1 );
                    }
                    break;

                case '>':
                    if( GetToken() == -1 ) return -1;
                    if( *TOKEN != '=' )          // '>='┐м╗ъ└┌░б ╛╞┤╧╢є╕щ
                    {
                        PutToken();
                        WriteBYTE( 2 );
                    }
                    else {
                        WriteBYTE( 3 );
                    }
                    break;

                case '!':
                    if( GetToken() == -1 ) return -1;
                    if( *TOKEN != '=' ) { Serror( 1 ); return -1; }
                    WriteBYTE( 4 );
                    break;

                case '=':
                    if( GetToken() == -1 ) return -1;
                    if( *TOKEN != '=' ) { Serror( 1 ); return -1; }
                    WriteBYTE( 5 );
                    break;
            }

            // ║ё▒│╟╥ ┤ы╗є└╟ ┐ь║п░к└╗ ├│╕о╟╤┤┘. ┐ь║п░к└║ ║п╝Ў└╠░┼│к ╝Ў─б└╠┤┘.
            if( GetToken() == -1 ) return -1;
            switch( TOKENTYPE )
            {
                case NUMERIC:
                    WriteBYTE( (char)value_ );
                    WriteInt( atoi(TOKEN) );
                    break;

                case VARIABLE:
                    WriteBYTE( (char)variable_ );
                    WriteInt( variable[TOK].n );
                    break;

                default: { Serror( 1 ); return -1; }
            }

            if( GetToken() == -1 ) return -1;
            if( *TOKEN != ')' ) { Serror( 1 ); return -1; }

            if( GetToken() == -1 ) return -1;
            if( *TOKEN != '{' ) { Serror( 1 ); return -1; }

            // ┴╢░╟└╠ ░┼┴■└╧░ц┐ь ┴б╟┴╟╥ ┴╓╝╥╕ж ░б╗є└╕╖╬ ╕╕╡щ╛ю 0└╕╖╬ ╝┬╞├
            WriteBYTE( (char)goto_ );
            WriteInt( 0 );

            ifelse[ifsp].off = outprog - oldoutprog - sizeof( int );
            ifelse[ifsp].d = ifsp;
            ifelse[ifsp].t = 0;
            ++ifsp;
            break;

        // else╣о└╗ ├│╕о╟╤┤┘.
        case else_:
            // goto╣о┐б ╟╪┤ч╟╧┤┬ ░к└╗ └·└х
            WriteBYTE( (char)goto_ );
            WriteInt( 0 );

            // if┐б╝н ░┼┴■└╧ ░ц┐ь ┴б╟┴╟╥ ┴╓╝╥╕ж ╟Ў└ч└╟ ┴╓╝╥╖╬ ╝┬╞├╟╤┤┘.
            *((int *)( oldoutprog + ifelse[ifsp].off)) += (sizeof( int ) + 1);

            if( GetToken() == -1 ) return -1;
            if( *TOKEN != '{' ) { Serror( 1 ); return -1; }
            if( ifelse[ifsp].d != ifsp ) { Serror( 1 ); return -1; }

            ifelse[ifsp].off = outprog - oldoutprog - sizeof( int );
            ifelse[ifsp].d = ifsp;
            ifelse[ifsp].t = 1;
            ++ifsp;
            break;

        // goto╣о└╗ ├│╕о
        case goto_:
            WriteBYTE( (char)goto_ );
            if( GetToken() == -1 ) return -1;
            if( TOKENTYPE != LABEL ) { Serror( 9 ); return -1; }
			// ╢є║з╕э└╗ label2┐б └·└х. └╠ ░к└║ │к┴▀┐б label1░· ║ё▒│╟╥╢з ╛▓└╙
			label2[label2_n].n = (int)(outprog - oldoutprog);
			strcpy( label2[label2_n++].s, TOKEN );
			WriteInt( 0 );        // ┴б╟┴╟╥ ┴╓╝╥╕ж └╙╜├╖╬ ╕╕╡ы
		break;

        // call╣о└╗ ├│╕о
        case call_:
            WriteBYTE( (char)call_ );

            if( GetToken() == -1 ) return -1;
            if( *TOKEN != '(' ) { Serror( 1 ); return -1; }

            if( GetToken() == -1 ) return -1;
            if( TOKENTYPE != USERFUNC ) { Serror( 15 ); return -1; }
            strcpy( userfunc2[user2_n].s, TOKEN );
            // call╣о└╕╖╬ ┴б╟┴╟╥ ░б╗є░°░г└╗ ╚о║╕╟╧░э 0└╗ ╝┬╞├
            userfunc2[user2_n++].n = outprog - oldoutprog;
            WriteInt( 0 );

            if( GetToken() == -1 ) return -1;
            if( *TOKEN != ')' ) Serror( 1 );
            break;

        // end╣о└╗ ├│╕о
        case end_:
            WriteBYTE( (char)end_ );
            if( ifsp > 0 ) { Serror( 3 ); return -1; }
            break;

        // switch╣о└╗ ├│╕о
        case switch_:
            ++switsp;

            if( GetToken() == -1 ) return -1;
            if( *TOKEN != '(' ) { Serror( 1 ); return -1; }

            if( GetToken() == -1 ) return -1;
            if( TOKENTYPE != VARIABLE ) { Serror( 22 ); return -1; }
            j = variable[TOK].n;

            if( GetToken() == -1 ) return -1;
            if( *TOKEN != ')' ) { Serror( 1 ); return -1; }

            // ╟┴╖╬▒╫╖е ├│└╜┐б ┴╢╗ч╟╤ case╣о└╟ ░╣╝Ў╕╕┼н ░°░г└╗ ╚о║╕
            for( i = 0; i < swit[switsp].total; i++ )
            {
                WriteBYTE( (char)ifequal_ );

                WriteBYTE( (char)variable_ );
                WriteInt( j );

                // ║ё▒│╟╥ ┤ы╗є└╗ └з╟╤ ░°░г└╗ ╚о║╕
                swit[switsp].numoff[i] = outprog - oldoutprog;
                WriteBYTE( 0 );
                WriteInt( 0 );

                // ╢є║з╕э┐б ╟Ў└ч ╜║└з─б└╟ ░к└╗ └·└х╟╪╝н ┤┘└╜┐б ║ё▒│╟╥╢з
                // ╗ч┐ы╟╤┤┘.
                sprintf( label2[label2_n].s, "case%02d_%02d", switsp, i );
                label2[label2_n++].n = outprog - oldoutprog;
                WriteInt( 0 );
            }

            // ╡Ё╞·╞о╣о└╠ └╓└╕╕щ ╢є║з╕э┐б ╣о└┌┐н└╗ ├▀░б╟╧┐й default╣о└╗ ╜╟╟р
            WriteBYTE( (char)goto_ );
            sprintf( label2[label2_n].s, "defa%02d", switsp );
            label2[label2_n++].n = outprog - oldoutprog;
            WriteInt( 0 );
            break;

        // case╣о└╗ ├│╕о
        case case_:
            // ╢є║з╕э┐б case╣о┐б ╟╪┤ч╟╧┤┬ ╣о└┌┐н└╗ ├▀░б╟╧┐й │к┴▀┐б ├│╕о╟╤┤┘.
            sprintf( label1[label1_n].s, "case%02d_%02d", switsp,
                swit[switsp].count );
            label1[label1_n++].n = outprog - oldoutprog;

            if( GetToken() == -1 ) return -1;
            switch( TOKENTYPE )
            {
                case NUMERIC:
                    *((char *)(oldoutprog +
                        swit[switsp].numoff[swit[switsp].count])) = (char)value_;
                    j = atoi( TOKEN );
                    break;

                case VARIABLE:
                    *((char *)(oldoutprog +
                        swit[switsp].numoff[swit[switsp].count])) = (char)variable_;
                    j = variable[TOK].n;
                    break;

                default: { Serror( 1 ); return -1; }
            }

            *((int *)(oldoutprog + 1 +
                swit[switsp].numoff[swit[switsp].count++])) = j;
            break;

        // default╣о└╗ ├│╕о
        case default_:
            // ╢є║з╕э┐б default╣о└╟ ╣о└┌┐н└╗ └╘╖┬╟╧┐й │к┴▀┐б ├│╕о
            sprintf( label1[label1_n].s, "defa%02d", switsp );
            label1[label1_n++].n = outprog - oldoutprog;
            break;

        // endswitch╣о└╗ ├│╕о
		case endswitch_:
            // switch╣о└╟ │б│▓└╗ └╟╣╠╟╤┤┘.
            if( swit[switsp].def != 1 ) {
                sprintf( label1[label1_n].s, "defa%02d", switsp );
                label1[label1_n++].n = outprog - oldoutprog;
            }
            sprintf( label1[label1_n].s, "defabreak%02d", switsp );
            label1[label1_n++].n = outprog - oldoutprog;

            swit[switsp].count = 0;
            break;

        // break╣о└╗ ├│╕о
        case break_:
            WriteBYTE( (char)goto_ );
            sprintf( label2[label2_n].s, "defabreak%02d", switsp );
            label2[label2_n++].n = outprog - oldoutprog;
            WriteInt( 0 );
            break;
    }

	return 1;
}




/* нхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнх
 ╟╘╝Ў╕э : GetFunction
 └╬  └┌ : ╛°└╜
 ╕о┼╧░к : ╛°└╜
 ╝│  ╕э : zs.dat┐б╝н ┴д└╟╟╤ ╟╘╝Ў╕э└╗ ║╨╝о╟╧┐й ╛╦╕┬└║ └█╛ў└╗ ╟╤┤┘.
          i┤┬ int╕ж └╟╣╠╟╧╕ч, s┤┬ ╣о└┌┐н└╗ └╟╣╠╟╤┤┘.
нхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнх */
int GetFunction( void )
{
    int i, slen, len, *p;
    int tok = TOK;

    WriteBYTE( (char)function[tok].n );          // ╟╘╝Ў└╟ ╣°╚г╕ж ╝┬╞├

    len = strlen( function[tok].format );  // ╕┼░│║п╝Ў└╟ ▒ц└╠╕ж ╛Є└╜

    if( GetToken() == -1 ) return -1;
    if( *TOKEN != '(' ){ Serror( 1 );  return -1; }

    for( i = 0; i < len; i++ ) {
        switch( function[tok].format[i] ) {
            case 'i':                      // int╟№└╗ ├│╕о
                if( GetToken() == -1 ) return -1;
                switch( TOKENTYPE )
                {
                    case NUMERIC:
                        WriteBYTE( (char)value_ );
                        WriteInt( atoi( TOKEN ) );
                        break;

                    case VARIABLE:
                        WriteBYTE( (char)variable_ );
//                        WriteInt( atoi( TOKEN ) );
                        WriteInt( variable[TOK].n );
                        break;

                    default:
                        { Serror( 6 ); return -1; }
                }
                break;

            case 's':                      // ╣о└┌┐н└╗ ├│╕о
                if( GetToken() == -1 ) return -1;
                if( TOKENTYPE != STRING ) {Serror( 6 ); return -1; }
                slen = strlen( TOKEN );
                WinZsIncode( (char *)TOKEN );        // ╣о└┌┐н└╗ ╛╧╚г╚н╟╘
//                strcpy( outprog, (char *)TOKEN );
                WriteBYTE( (char)value_ );
                p = (int*)outprog;
                WriteInt( slen );                       // ╣о└┌┐н└╟ ▒ц└╠╕ж▒т╖╧
                memcpy( outprog, (char*)TOKEN, slen );    // ╣о└┌┐н└╗ └·└х
                outprog += slen;
REPEA:
                if( GetToken() == -1 ) return -1;
                if( TOKENTYPE == STRING )
                {
                    slen = strlen( TOKEN );
                    WinZsIncode( (char *)TOKEN );        // ╣о└┌┐н└╗ ╛╧╚г╚н╟╘
                    (*p) += slen;
                    memcpy( outprog, (char*)TOKEN, slen );
                    outprog += slen;
                    goto REPEA;
                }
                else
                {
                    PutToken();
                }

                break;

            default: { Serror( 6 ); return -1; }
        }

        // ╕┼░│ ║п╝Ў╗ч└╠└╟ ','╕ж ├│╕о╟╤┤┘.
        if( len > 1 && i != (len-1) ) {
            if( GetToken() == -1 ) return -1;
            if( *TOKEN != ',' ) { Serror( 4 ); return -1; }
        }
    }
    if( GetToken() == -1 ) return -1;
    if( *TOKEN != ')' ) {Serror( 1 );  return -1; }

	return 1;
}



/* нхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнх
 ╟╘╝Ў╕э : GetUserFunc
 └╬  └┌ : ╛°└╜
 ╕о┼╧░к : ╛°└╜
 ╝│  ╕э : ╟Ў└ч└╟ ├т╖┬╣Ў╞█└╟ └з─б╕ж └п└· ╟╘╝Ў ╣Ў╞█┐б ▒т╖╧╟╤┤┘.
нхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнх */
void GetUserFunc( void )
{
	userfunc1[user1_n++].n = outprog - oldoutprog;
}



/* нхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнх
 ╟╘╝Ў╕э : Delimeter
 └╬  └┌ : ╛°└╜
 ╕о┼╧░к : ╛°└╜
 ╝│  ╕э : ▒╕║╨└┌╕ж ╣▐╛╥└╗ ░ц┐ь ├│╕о╟╤┤┘.
          '#'└║ └╬┼м╖ч╡х╣о└╗ └╟╣╠╟╤┤┘. └╬┼м╖ч╡х ╣о└╠╢є╕щ ╟Ў└ч ├т╖┬╣Ў╞█└╬
          outprog┐б └╬┼м╖ч╡х ╚н└╧└╟ │╗┐ы└╗ └╨╛ю╝н ╛┤┤┘.
нхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнх */
int Delimeter( void )
{
    FILE *fp;
    char temp[1024];
    int i;

    if( *TOKEN != '#' ) { Serror( 1 ); return -1; }

    if( GetToken() == -1 ) return -1;
	if( TOKENTYPE != COMMAND || comm[TOK].n != include_ ) Serror( 1 );

    if( GetToken() == -1 ) return -1;
    if( TOKENTYPE != STRING ) { Serror( 1 ); return -1; }

    fp = fopen( TOKEN, "rb" );
    if( fp == NULL ) { Serror( 23 ); return -1; }

    while( 1 ) {
        i = fread( temp, 1, 1024, fp );
        fwrite( temp, 1, i, outfile );
        INCLUDEFILESIZE += i;
        SOURCEFILESIZE += i;
        if( i != 1024 ) break;

    }
    fclose( fp );

	return 1;
}




/* нхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнх
 ╟╘╝Ў╕э : Run
 └╬  └┌ : ╛°└╜
 ╕о┼╧░к : ╛°└╜
 ╝│  ╕э : ░в ╕э╖╔┐б ╕┬┤┬ ╟╘╝Ў╕ж ╚г├т╟╤┤┘.
нхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнх */
int  Run( void )
{
    while( 1 ) {
        if( GetToken() == -1 ) return -1;

        if( TOKENTYPE == END ) break;        // ╚н└╧└╟ │б└╠╢є╕щ

        else if( *TOKEN == '}' ) {                // if,else╣о└╟ ┴╛░с└┌╢є╕щ
            if( First() == -1 ) return -1;
            continue;
        }

        else if( TOKENTYPE == NUMERIC )       // ╣о└х└╟ ├│└╜┐б┤┬ ╝¤└┌░б ┐├╝Ў╛°┤┘.
		{ Serror( 1 ); return -1; }

        else if( TOKENTYPE == DELIMITER )     // ▒╕║╨└┌ ╕э╖╔└╗ ├│╕о
        {
            if( Delimeter() == -1 ) return -1;;
            continue;
        }

        else if( TOKENTYPE == VARIABLE ) {
            if( Inc() == -1 ) return -1;
            continue;
        }

        else if( TOKENTYPE == LABEL ) {
            GetLabel();
            continue;
        }

        else if( TOKENTYPE == COMMAND ) {
            if( GetCommand() == -1 ) return -1;
            continue;
        }

        else if( TOKENTYPE == FUNCTION ) {
            if( GetFunction() == -1 ) return -1;
            continue;
        }

        else if( TOKENTYPE == USERFUNC ) {
            GetUserFunc();
            continue;
        }

        { Serror( 1 ); return -1; }
    }
    if( ifsp > 0 ) { Serror( 3 ); return -1; }

	return 1;
}



/* нхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнх
 ╟╘╝Ў╕э : LoadData
 └╬  └┌ : ╛°└╜
 ╕о┼╧░к : ╛°└╜
 ╝│  ╕э : zs.dat╕ж ┐└╟┬╟╪╝н ╛╦╕┬└║ ╟╪╝о└╗ ╟╧░э ║п╝Ў└╟ └╠╕з░· ┤ы╟е░к, ╟╘╝Ў└╟
          └╠╕з░· ┤ы╟е░к└╗ ╝┬╞├╟╘
нхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнх */
int  LoadData( char *szdat )
{
    FILE *fp;
    char temp[ FILENAME_MAX];
    DWORD size;
    int i = 0, j;
    BYTE *p;

	sprintf( temp, "./script/%s", szdat );

    fp = fopen( temp, "rb" );
    if( fp == NULL ) { return 0; }

    size = filelength( fileno(fp) );

    wzsprog = p = (BYTE *)ZSAlloc( size + 1 );
	fread( wzsprog, (size_t)size, 1, fp );
    fclose( fp );

    if( *(wzsprog + size -1)  == 0x1a )
        *(wzsprog+size-1) = 0;
    else
        *(wzsprog+size) = 0;


    //printf( "\nZS.DAT file compile" );

	while( 1 ) {
		if( GetToken() == -1 ) return -1;
		if( TOKENTYPE == END ) break;

        // ║п╝Ў╕ж ╟е╜├╟╧┤┬ ╣о└┌┐н└╗ ├г┤┬┤┘.
		if( strcmp( TOKEN, "variable" ) != 0 ) { Serror( 1 ); return -1; }


		// ║п╝Ў┐б ╟╪┤ч╟╧┤┬ ┤ы╟е╕э░· ▒╫ ░к└╗ variable╣ш┐н┐б ╝┬╞├╟╤┤┘.
		while( 1 ) {
			if( GetToken() == -1 ) return -1;
			if( !strcmp( TOKEN, "end" ) ) break;        // │б└╠╕щ ┤┘└╜└╕╖╬

			if( TOKENTYPE != STRING ) Serror( 1 );
			j = SearchVariable( TOKEN );                // ░░└║ ║п╝Ў░б └╓┤┬┴Ў ░╦╗ч
			if( j != -1 ) Serror( 14 );
			strcpy( variable[i].s, TOKEN );

			if( GetToken() == -1 ) return -1;
			if( TOKENTYPE != NUMERIC ) Serror( 1 );
			j = atoi( TOKEN );
			if( j > 30000 ) { Serror( 18 ); return -1; }
			variable[i++].n = j;
		}

		i = 0;

		if( GetToken() == -1 ) return -1;
		if( strcmp( TOKEN, "function" ) != 0 ) { Serror( 1 ); return -1; }

		// ╟╘╝Ў┐б ╟╪┤ч╟╧┤┬ ┤ы╟е╕э░· ▒╫ ░к└╗ function╣ш┐н┐б ╝┬╞├╟╤┤┘.
		while( 1 ) {
			if( GetToken() == -1 ) return -1;
			if( !strcmp( "end", TOKEN )) break;

			if( TOKENTYPE != STRING ) { Serror( 1 ); return -1; }
			j = SearchFunction( TOKEN );
			if( j != -1 ) Serror( 14 );                 // ░░└║ ╟╘╝Ў░б └╓┤┬┴Ў ░╦╗ч
			strcpy( function[i].s, TOKEN );

			GetToken ();
			if( TOKENTYPE != STRING ) { Serror( 1 ); return -1; }
			if( !strcmp( TOKEN, "null" ) )              // ╕┼░│║п╝Ў░б ╛°└╕╕щ
				function[i].format[0] = 0;
			else
				strcpy( function[i].format, TOKEN );    // ╕┼░│║п╝Ў░б └╓└╕╕щ

			if( GetToken() == -1 ) return -1;
			if( TOKENTYPE != NUMERIC ) { Serror( 1 ); return -1; }
			j = atoi( TOKEN );
			if( j > 0xcf ) { Serror( 18 ); return -1; }
			function[i++].n = j;
		}

		if( i == 0 ) { Serror( 1 ); return -1; }
	}
	LINE = 0;
    ZSfree( p );

	return 1; 
    //printf( " --------> completed.\n\n" );
}




/* нхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнх
 ╟╘╝Ў╕э : InitProgram
 └╬  └┌ : s = ──╞─└╧╟╧░э└┌ ╟╧┤┬ ╚н└╧└╟ └╠╕з
 ╕о┼╧░к : ╛°└╜
 ╝│  ╕э : ╝╥╜║╕ж ╕▐╕Ё╕о╖╬ └╨╛ю╡щ└╬╚─, ├т╖┬╟╥ ╚н└╧└╟ └╠╕з└╗ ╗¤╝║╜├┼▓┤┘.
нхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнх */
int  InitProgram( char *s )
{
    FILE *fp;
    char *p;

    fp = fopen( s, "rb" );
    if( fp == NULL ) { 
        exit( 1 );
    }

    SOURCEFILESIZE = filelength( fileno(fp) );

    fread( wzsprog, SOURCEFILESIZE, 1, fp );
    fclose( fp );

    if( *(wzsprog + (int)SOURCEFILESIZE -1) == 0x1a )
        *(wzsprog + (int)SOURCEFILESIZE-1) = 0;
    else
        *(wzsprog + (int)SOURCEFILESIZE) = 0;

    strcpy( TARGETFILENAME, s );
    p = strchr( TARGETFILENAME, '.' );
    strcpy( p, ".ZSC" );

/*	if( GameMakeFlag == ON )
	{
		outfile = Fopen( TARGETFILENAME, "wb" );
		if( fp == NULL ) { 
	        exit( 1 );
		}
	}
*/
	return TRUE;
}



/* нхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнх
 ╟╘╝Ў╕э : Path1
 └╬  └┌ : ╛°└╜
 ╕о┼╧░к : ╛°└╜
 ╝│  ╕э : ╝╥╜║╕ж ╟╤╣° └╨└╕╕щ╝н ╣о╣¤└√ ┐б╖п╕ж ├╝┼й╟╤┤┘.
нхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнх */
int Path1( void )
{
    BYTE *p = wzsprog;
    int j;
    int func = 0;
    int funcdepth = 0;
    int if_else_count = 0;
    int switch_case = 0;
    int switch_count = 0;

    while( 1 ) {
        if( GetToken() == -1 ) return -1;
        if( TOKENTYPE == END ) break;

        // if, else└╟ ░╣╝Ў╕ж ░╦╗ч╟╪╝н ┐б╖п╕ж ├╝┼й╟╤┤┘.
        if( *TOKEN == '{' ) ++if_else_count;
        if( *TOKEN == '}' ) --if_else_count;

        // ╢є║з╕э└╧ ░ц┐ь┐б┤┬ ╢є║з└╗ ├г╛╞║╕░э, └╓└╕╕щ ╢є║з ┴▀║╣ ┐б╖п╕ж ├т╖┬╟╧░э
        // ╛°└╕╕щ ╡ю╖╧╟╤┤┘.
        if( TOKENTYPE == LABEL )
        {
            if( strlen( TOKEN ) > LABEL_LENGTH ) { Serror( 8 ); return -1; }
            j = SearchLabel( TOKEN );
            if( j != -1 ) Serror( 14 );
            strcpy( label1[label1_n++].s, TOKEN );
        }

        // └п└·░б ┴д└╟╟╤ ╟╘╝Ў└╠╕щ ╟╘╝Ў╕ж ├г╛╞║╕░э, └╓└╕╕щ ╟╘╝Ў ┴▀║╣ ┐б╖п╕ж
        // ├т╖┬╟╧░э ╛°└╕╕ч ╡ю╖╧└╗ ╟╤┤┘.
        if( TOKENTYPE == USERFUNC )
        {
            if( TOK != -1 ) { Serror( 15 ); return -1; }
            strcpy( userfunc1[funcdepth++].s, TOKEN );
            if( func++ != 0 ) { Serror( 13 ); return -1; }
        }

        if( TOKENTYPE == COMMAND ) {
            switch( comm[TOK].n ) {
                // switch╣о└╟ case┐═ default╣о└╟ ░╣╝Ў╕ж ╚о└╬╟╧░э ┐б╖п╕ж ░╦╗ч
                case switch_:
                    ++switch_case;
                    ++switch_count;
                    break;

                case endswitch_:
                    --switch_case; break;

                case default_:
                    swit[switch_count].def = 1; break;

                case case_:
                    ++swit[switch_count].total; break;

                // call╕э╖╔╣о ┤┘└╜┐б╡╡ ╢є║з╕э└╠ ┐└▒т╢з╣о┐б └╠░═└╗ ╟╟╟╤┤┘.
                case call_:
                    if( GetToken() == -1 ) return -1;
                    if( GetToken() == -1 ) return -1;
                    if( GetToken() == -1 ) return -1; break;

                // end╣о└╗ ├│╕о╟╧╕ч if-else, switch-endswitch, ▒╫╕о░э ╟╘╝Ў░б
                // ┴д╗є└√└╬░б╕ж ╞╟┤▄╟╤┤┘.
                case end_:
                    if( func-- != 1 )  { Serror( 13 ); return -1; }
                    if( if_else_count != 0 ) { Serror( 12 ); return -1; }
                    if( switch_case != 0 ) { Serror( 21 ); return -1; }
                    break;

                case goto_:
                    if( GetToken() == -1 ) return -1;
                    break;
            }
        }
    }
    if( func > 0 ) { Serror( 13 ); return -1; }

    ifsp = 0;
    wzsprog = p;
    LINE = 0;

	return TRUE; 
}




/* нхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнх
 ╟╘╝Ў╕э : EndProgram
 └╬  └┌ : ╛°└╜
 ╕о┼╧░к : ╛°└╜
 ╝│  ╕э : ╟┴╖╬▒╫╖е└╟ ╕╟ ╕╢┴Ў╕╖┐б ╜╟╟р╡╟╕ч, ╢є║з╕э└╟ └з─б╕ж ▒т╖╧,
          ╟╘╝Ў╕э└╟ └з─б╕ж ▒т╖╧, ╟╘╝Ў└╟ ░╣╝Ў╕ж ├т╖┬╚н└╧└╟ ├│└╜ ║╬║╨┐б ▒т╖╧╟╤┤┘.
нхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнхнх*/
int EndProgram( void )
{
    int i, j;
    int size = 0;

    // ┐°╖б└╟ ╢є║з╕э░· └п└·░б ╗ч┐ы╟╤ ╢є║з╕э└╗ ╝н╖╬ ║ё▒│╟╪╝н ▒╫░к└╗ ├т╖┬╟╤┤┘.
    for( i = 0; i < label2_n; i++ ) {
        j = SearchLabel( label2[i].s );
        if( j == -1 ) 
		{
            strcpy( TOKEN, label2[i].s );
            { Serror( 9 ); return -1; }
        }

        *((int *)(oldoutprog+label2[i].n)) = label1[j].n;
    }


    // ┐°╖б└╟ ╟╘╝Ў╕э░· └п└·░б ╗ч┐ы╟╤ ╟╘╝Ў╕э└╗ ╝н╖╬ ║ё▒│╟╪╝н ▒╫░к└╗ ├т╖┬╟╤┤┘.
    for( i = 0; i < user2_n; i++ ) {
        j = SearchUserFunc( userfunc2[i].s );
        if( j == -1 ) {
            strcpy( TOKEN, userfunc2[i].s );
            Serror( 15 );
        }

        *((int *)(oldoutprog+userfunc2[i].n)) = userfunc1[j].n;
    }

	for( i = 0; userfunc1[i].s[0]; i++ ) func_off[i] = userfunc1[i].n;
	TotalFunction = i;


/*
	if( GameMakeFlag == ON )
	{
		// ╕Ё╡ч ╟╘╝Ў└╟ ░╣╝Ў╕ж ╚н└╧└╟ ├│└╜┐б ▒т╖╧└╗ ╟╧░э ╟╘╝Ў└╟ ┐╔╝┬░к└╗ ▒т╖╧╟╤┤┘.
		temp = ftell( outfile );
		fseek( outfile, 8, SEEK_CUR );        // ╟ь┤ї╕ж ├т╖┬╟╧▒т└з╟╤ ┐й╣щ

		for( i = 0; userfunc1[i].s[0]; i++ )
		{
			fwrite( &userfunc1[i].n, 1, sizeof( int ), outfile );
			size += sizeof( int );
		}

		// ──╞─└╧╡╚ ░с░·╕ж ╚н└╧╖╬ ├т╖┬╟╤┤┘.
		size += (outprog - oldoutprog - ( i * sizeof( int )) );
		fwrite( oldoutprog, outprog - oldoutprog, 1, outfile );

		fseek( outfile, temp, SEEK_SET );
		fwrite( &size, 1, sizeof( int ), outfile );        // ╚н└╧└╟ ┼й▒т╕ж ▒т╖╧
		fwrite( &i, 1, sizeof( int ), outfile );           // ╟╘╝Ў└╟ ░╣╝Ў╕ж ▒т╖╧
		fclose( outfile );
	}
*/
#ifdef MAKE_EXE_FILE
    printf( "\nTotal compile line     : %10d lines\n", --LINE );
    printf( "\nSource file size       : %10d BYTEs\n", SOURCEFILESIZE );
    printf( "\nTarget file size       : %10d BYTEs\n\n",        size + INCLUDEFILESIZE + i * sizeof( int ) );
#endif

	return TRUE;
}



static char *Filename;
static int Totalcount;


/*===========================================================================
   ╜║╟┴╢є└╠╞о╖╬ ╕╕╡щ ╕Ё╡ч ╚н└╧└╗ ░╦╗Ў╟╤┤┘.
===========================================================================*/
int SearchFile( char *fn )
{
    char temp[FILENAME_MAX], *p, (*f)[FILENAME_MAX];
    //struct find_t ff;
	struct	_finddata_t ff;
	int handle, c;

    strcpy( temp, fn );
    p = strchr( temp, '.' );
    if( p )
        strcpy( p, ".ZS" );
    else
        strcat( temp, ".ZS" );

    f = (char (*)[FILENAME_MAX])Filename;

	handle =  _findfirst( temp, &ff);
	if( handle == -1 ) return 0 ;
	c = 0;
    while( !c )
    {
        strcpy( (char *)f++, ff.name );
        Totalcount++;

        c = _findnext( handle, &ff );
    }

	return Totalcount;
}


#ifdef MAKE_EXE_FILE	
	void main( int argc, char *argv[] )
	{
		int i;
		char temp[FILENAME_MAX], (*f)[FILENAME_MAX];

		printf( "\n   ZS Script Compiler For Win95  Version 2.0\n" );
		printf( "----------------------------------------------------------------\n");
		
		wzsprog = oldwzsprog = (BYTE *)ZSAlloc( 100000 + 1 );
		outprog = oldoutprog = (BYTE *)ZSAlloc( 50000 );
		Filename = ZSAlloc( FILENAME_MAX * 2000 );

		if( argc == 1 )	strcpy( temp, "*.*" );
		else			strcpy( temp, argv[1] );

		if( SearchFile( temp ) ) LoadData();

		f = (char (*)[FILENAME_MAX])Filename;
		for( i = 0; i < Totalcount; i++, f++ )
		{
			wzsprog = oldwzsprog;
			outprog = oldoutprog;
			memset( wzsprog, 0, SOURCEFILESIZE + 1 );

			memset( label1,		0,	sizeof( COMMSET )	*	MAX_SCR_ARRAY );            // ┐°╖б ╢є║з└╟ │╗┐ы└╗ └·└х╟╧┤┬ ║п╝Ў
			memset( label2,		0,	sizeof( COMMSET )	*	MAX_SCR_ARRAY );            // goto╣о ┤┘└╜┐б ╛▓└╬ ╢є║з└╗ └·└х
			memset( ifelse,		0,	sizeof( IF_ELSE )	*	MAX_SCR_ARRAY );            // if, else╣о└╟ │╗┐ы└╗ └·└х
			memset( userfunc1,	0,	sizeof( COMMSET )	*	MAX_SCR_ARRAY );            // ┐°╖б ╟╘╝Ў╕э└╟ │╗┐ы└╗ └·└х
			memset( userfunc2,	0,	sizeof( COMMSET )	*	MAX_SCR_ARRAY );            // call╣о ┤┘└╜┐б ╛▓└╬ ╟╘╝Ў╕ж └·└х
			memset( swit,		0,	sizeof( SWITCHCASE )*	 50 );            // ╟╧│к└╟ switch╣о┐б╝н ░в░в└╟ case╣о└╗└·└х

			printf( " %3d/%3d     : %13s File Compiling...........\n", i+1, Totalcount, (char*)f );
			

			ifsp = 0;                            // if, else└╟ ╜║┼├░к
			switsp = 0;                          // switch└╟ ║п└з░к
			label1_n=0, label2_n = 0;              // ┐°╖б└╟ ╢є║з░к░· ╛▓┐й┴° ╢є║з░к└╗ └·└х
			user1_n = 0, user2_n = 0;                // ┐°╖б└╟ ╟╘╝Ў░к░· 
			
			
			InitProgram( (char*)f );
			Path1();
			Run();
			EndProgram();
		}

		printf( "\n    %d ZS Files Compiled ..\n", Totalcount );
		printf(   "    %d Error occured...\n", ErrorCount );
		printf( "-------------------------------------------Copyright(c),1995 F.E.W \n");
		printf( "-------------------------------------------------- Coded by Phyneix  \n");
		
		ZSfree( oldwzsprog );
		ZSfree( oldoutprog );
		ZSfree( Filename );

		_getch();
	}

#else
	
	
void InitTextScript( void )
{	
	oldwzsprog = (BYTE *)ZSAlloc( 100000 + 1 );
	oldoutprog = (BYTE *)ZSAlloc( 50000 );
}	
	

	
	
void EndTextScript( void )
{	
	if( oldwzsprog != NULL ) { ZSfree( oldwzsprog ); oldwzsprog = NULL; }
	if( oldoutprog != NULL ) { ZSfree( oldoutprog ); oldoutprog = NULL; }
}	
	
	
	
void NotePad( char *name )
{	
	//"NotePad.exe"
//	ShellExecute(NULL, NULL, SysInfo.notepad, name, NULL, SW_SHOWNORMAL);
}	
	
	
BYTE *LoadTextScript( char *name )
{	
	LINE = 0;
	
	TOK = 0; // ^^^^ 0308
	memset( variable, 0, sizeof( COMMSET ) *  2000 );	//MAX_SCR_ARRAY );             // ╗ч┐ы└┌░б ┴д└╟╟╤ ║п╝Ў└╟ │╗┐ы└╗ └·└х
	memset( function, 0, sizeof( USER_FUNC ) * 1000 ); //MAX_SCR_ARRAY );           // └п└·░б ┴д└╟╟╤ ╟╘╝Ў╕ж └·└х
	
	LoadData( "Zs.Dat" );	

	wzsprog = oldwzsprog;
	outprog = oldoutprog;

	strcpy( Wz_scriptfilename, name );

	memset( wzsprog, 0, 100000 + 1 );
	memset( (char*)label1,		0,	sizeof( COMMSET )	*	100 ); // MAX_SCR_ARRAY );            // ┐°╖б ╢є║з└╟ │╗┐ы└╗ └·└х╟╧┤┬ ║п╝Ў
	memset( (char*)label2,		0,	sizeof( COMMSET )	*	100 ); // MAX_SCR_ARRAY );            // goto╣о ┤┘└╜┐б ╛▓└╬ ╢є║з└╗ └·└х
	memset( (char*)ifelse,		0,	sizeof( IF_ELSE )	*	500 ); // MAX_SCR_ARRAY );            // if, else╣о└╟ │╗┐ы└╗ └·└х
	memset( (char*)userfunc1,	0,	sizeof( COMMSET )	*	1000 );//MAX_SCR_ARRAY );            // ┐°╖б ╟╘╝Ў╕э└╟ │╗┐ы└╗ └·└х
	memset( (char*)userfunc2,	0,	sizeof( COMMSET )	*	1000 ); //MAX_SCR_ARRAY );            // call╣о ┤┘└╜┐б ╛▓└╬ ╟╘╝Ў╕ж └·└х
	memset( (char*)swit,		0,	sizeof( SWITCHCASE )*	 50 );						// ╟╧│к└╟ switch╣о┐б╝н ░в░в└╟ case╣о└╗└·└х

	ifsp		= 0;                   // if, else└╟ ╜║┼├░к
	switsp		= 0;                   // switch└╟ ║п└з░к
	label1_n	= 0, label2_n	= 0;   // ┐°╖б└╟ ╢є║з░к░· ╛▓┐й┴° ╢є║з░к└╗ └·└х
    user1_n		= 0, user2_n	= 0;   // ┐°╖б└╟ ╟╘╝Ў░к░· 
	funclabelsp = 0;

	if( InitProgram( name ) == -1 ) goto ERROR_;
	if( Path1()				== -1 ) goto ERROR_;
	if( Run()				== -1 ) goto ERROR_;
	if( EndProgram()		== -1 ) goto ERROR_;

	CLoadScript = SCRIPT_NEW;
	return oldoutprog;
ERROR_:

	char nn[ FILENAME_MAX];
	strcpy( nn, Wz_scriptfilename );

	for( int i = strlen( nn ) - 1  ; i > 0  ; i -- )	   if( *(nn + i ) == '\\' ) break;

//	sprintf( temp, "'%s'╕ж ┤┘╜├ ╖╬╡х ╟╒┤╧┤┘.", strupr(nn+ i +1)  );
//	if( YesOrNo( temp, "╚о└╬") == IDYES ) goto AGAIN_;

	return NULL;
}


#endif







